# スタックの使用法とスタックオーバーフローのチェック

## スタックの使用法

各タスクは自身のスタックを保持します。xTaskCreate()を使ってタスクを
作成するとタスクのスタックとして使われるメモリがFreeRTOSのヒープから
自動的に確保されます。その大きさはxTaskCreate()API関数に渡される
パラメータにより決められます。xTaskCreateStatic()を使ってタスクが
作成された場合、タスクのスタックとして使用されるメモリは
アプリケーションの作者により事前に割り当てられます。スタックオーバー
フローはアプリケーションを不安定にするきわめて一般的な原因です。
そのため、FreeRTOSはそのような事態の検出と修正を支援するために2つの
オプション機構を提供しています。使用するオプションは構成定数
`configCHECK_FOR_STACK_OVERFLOW`を使って設定します。

これらのオプションはメモリマップがセグメント化されていない
アーキテクチャでしか使用できないことに注意してください。また、
RTOSカーネルのオーバーフ ローチェックが行われる前にスタック破壊に
応答してフォールトや例外を生成するプロセッサもあります。
`configCHECK_FOR_STACK_OVERFLOW`に0を設定していない場合。
アプリケーションはスタックオーバーフローフック関数を提供する必要が
あります。フック関数の名前は`vApplicationStackOverflowHook()`であり、
次のプロトタイプを持つ必要があります・

```c
void vApplicationStackOverflowHook( TaskHandle_t xTask、
                                    signed char *pcTaskName )；
```

フック関数に渡されるパラメタ`xTask`と`pcTaskName`はそれぞれ対象とする
タスクのハンドルと名前です。ただし、オーバーフローの深刻度によっては
これらのパラメータ自体が破損している可能性があり、その場合は
`pxCurrentTCB`変数を直接検査します。

スタックオーバーフローチェックにはコンテキストスイッチのオーバー
ヘッドが発生するので開発段階またはテスト段階でのみ使用することを
推奨します。

## スタックオーバーフローの検出 - 方法 1

スタックが最大（最深）値に達するのはRTOSカーネルがタスクを実行状態
からスワップアウトした後である可能性が高いです。スタックにタスク
コンテキストが積まれる時だからです。この時点で、RTOSカーネルは
プロセッサのスタックポインタが有効なスタック空間内に残っていることを
チェックできます。スタックポインタが有効なスタックの範囲外の値を
含んでいる場合、スタックオーバーフローフック関数が呼び出されます。

この方法は迅速ですがすべてのスタックオーバーフローを捕捉できる
保証はありません。この方法を使用するには
`configCHECK_FOR_STACK_OVERFLOW `に1を設定します。

## スタック・オーバーフローの検出 - 方法2

タスクが作成される際、スタックは既知の値で満たされます。タスクを
実行状態からスワップアウトする際にRTOSカーネルは有効なスタック範囲の
最後の16バイトをチェックしてその既知の値がタスクまたは割り込み
アクティビティによって上書きされていないか確認することができます。
スタックオーバーフローフック関数が呼び出されるとこれらの16バイトは
初期値のままでないはずです。

この方法は1番目の方法より効率は悪いですがそれでもかなり速い方法です。
スタックオーバーフローを捕捉できる可能性は非常に高いですがそれでも
すべてのオーバーフ ローを捕捉できる保証はありません。

この方法を使用するには`configCHECK_FOR_STACK_OVERFLOW`に2を設定します。


## スタック・オーバーフローの検出 - 方法 3

このメソッドを使用するには`configCHECK_FOR_STACK_OVERFLOW`に3を設定
します。

この方法はいくつかのポートでのみ利用できます。利用可能な場合、
このメソッドはISRスタックチェックを有効にします。ISRスタック
オーバーフローが検出されるとアサートがトリガーされます。この場合、
スタックオーバーフローフック関数はタスクスタック固有であり、
ISRスタック固有ではないので呼び出されないことに注意してください。
